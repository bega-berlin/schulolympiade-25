# 🚀 Migration von JSON zu MySQL - Schulolympiade Dashboard

## 📋 Übersicht der Komponenten

1. **Hauptdashboard** (Port 3000) - Zeigt Statistiken und Ranglisten
2. **Daten-Editor** (Port 3003) - Bearbeitet Wettkampfergebnisse
3. **Emoji-Editor** (Port 3004) - Bearbeitet Emoji-Mappings
4. **MySQL Datenbank** (Port 3308) - Zentrale Datenspeicherung

---

## 🐳 Schritt 1: Docker Setup für MySQL

### 1.1 Erstelle `docker-compose.yml`:

```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    container_name: schulolympiade_mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: olympiade2025!
      MYSQL_DATABASE: schulolympiade
      MYSQL_USER: olympiade_user
      MYSQL_PASSWORD: ongOlympiade#2025
    ports:
      - "3308:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - olympiade_network

volumes:
  mysql_data:

networks:
  olympiade_network:
    driver: bridge
```

### 1.2 Erstelle `init.sql` für Datenbank-Schema:

```sql
-- Datenbank erstellen (falls nicht existiert)
CREATE DATABASE IF NOT EXISTS schulolympiade;
USE schulolympiade;

-- Tabelle für Wettkampfergebnisse
CREATE TABLE IF NOT EXISTS results (
    id INT AUTO_INCREMENT PRIMARY KEY,
    team VARCHAR(100) NOT NULL,
    disziplin VARCHAR(100) NOT NULL,
    punkte INT NOT NULL,
    platz INT NOT NULL,
    uhr TIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_team (team),
    INDEX idx_disziplin (disziplin),
    INDEX idx_uhr (uhr)
);

-- Tabelle für Emoji-Mappings
CREATE TABLE IF NOT EXISTS emoji_mappings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    emoji VARCHAR(10) NOT NULL,
    trigger_text VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_trigger (trigger_text)
);

-- Tabelle für Authentifizierungs-Tokens
CREATE TABLE IF NOT EXISTS auth_tokens (
    id INT AUTO_INCREMENT PRIMARY KEY,
    token VARCHAR(64) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL 24 HOUR),
    INDEX idx_token (token)
);

-- View für Team-Statistiken
CREATE VIEW team_stats AS
SELECT 
    team,
    COUNT(*) as events,
    SUM(punkte) as total_points,
    AVG(platz) as avg_place
FROM results
GROUP BY team
ORDER BY total_points DESC;

-- View für Disziplin-Statistiken  
CREATE VIEW discipline_stats AS
SELECT 
    disziplin,
    COUNT(DISTINCT team) as participants,
    COUNT(*) as total_events,
    AVG(punkte) as avg_points
FROM results
GROUP BY disziplin;
```

### 1.3 Starte Docker Container:

```bash
# Im Projektverzeichnis ausführen:
docker-compose up -d

# Prüfe ob Container läuft:
docker ps

# Logs anzeigen:
docker-compose logs -f mysql
```

---

## 📦 Schritt 2: NPM Dependencies installieren

Erstelle `package.json` im Hauptverzeichnis:

```json
{
  "name": "schulolympiade-mysql",
  "version": "2.0.0",
  "description": "Schulolympiade Dashboard mit MySQL",
  "scripts": {
    "start": "node server.js",
    "migrate": "node migrate.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.0",
    "dotenv": "^16.3.1",
    "crypto": "^1.0.1"
  }
}
```

Installiere Dependencies:
```bash
npm install
```

---

## 🔧 Schritt 3: Erstelle `.env` Datei

```env
# MySQL Verbindung
DB_HOST=192.168.100.73
DB_PORT=3308
DB_USER=olympiade_user
DB_PASSWORD=ongOlympiade#2025
DB_NAME=schulolympiade

# Admin Credentials
ADMIN_USER=DauView25
ADMIN_PASS=ongOlympiade#2025

# Server Ports
MAIN_PORT=3000
EDIT_PORT=3003
EMOJI_PORT=3004
```

---

## 🗄️ Schritt 4: Datenbank-Verbindungsmodul

### Erstelle `db.js`:

```javascript
// === DATENBANK VERBINDUNGSMODUL ===
const mysql = require('mysql2/promise');
require('dotenv').config();

// Connection Pool für bessere Performance
const pool = mysql.createPool({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
    enableKeepAlive: true,
    keepAliveInitialDelay: 0
});

// Test Verbindung
async function testConnection() {
    try {
        const connection = await pool.getConnection();
        console.log('✅ MySQL Verbindung erfolgreich!');
        connection.release();
        return true;
    } catch (error) {
        console.error('❌ MySQL Verbindungsfehler:', error.message);
        return false;
    }
}

module.exports = { pool, testConnection };
```

---

## 🔄 Schritt 5: Migration Script

### Erstelle `migrate.js`:

```javascript
// === MIGRATIONS-SCRIPT: JSON → MySQL ===
const fs = require('fs').promises;
const path = require('path');
const { pool } = require('./db');

async function migrateResults() {
    console.log('📊 Starte Migration der Wettkampfergebnisse...');
    
    try {
        // Lese results.json
        const jsonPath = path.join(__dirname, 'data', 'results.json');
        const jsonData = await fs.readFile(jsonPath, 'utf8');
        const results = JSON.parse(jsonData);
        
        // Lösche alte Daten
        await pool.execute('TRUNCATE TABLE results');
        
        // Füge neue Daten ein
        for (const result of results) {
            await pool.execute(
                'INSERT INTO results (team, disziplin, punkte, platz, uhr) VALUES (?, ?, ?, ?, ?)',
                [result.Team, result.Disziplin, result.Punkte, result.Platz, result.Uhr]
            );
        }
        
        console.log(`✅ ${results.length} Wettkampfergebnisse migriert!`);
    } catch (error) {
        console.error('❌ Fehler bei Results-Migration:', error);
    }
}

async function migrateEmojis() {
    console.log('😊 Starte Migration der Emoji-Mappings...');
    
    try {
        // Lese emojiMap.json
        const jsonPath = path.join(__dirname, 'data', 'emojiMap.json');
        const jsonData = await fs.readFile(jsonPath, 'utf8');
        const emojis = JSON.parse(jsonData);
        
        // Lösche alte Daten
        await pool.execute('TRUNCATE TABLE emoji_mappings');
        
        // Füge neue Daten ein
        for (const emoji of emojis) {
            await pool.execute(
                'INSERT INTO emoji_mappings (emoji, trigger_text) VALUES (?, ?)',
                [emoji.Emoji, emoji.Trigger]
            );
        }
        
        console.log(`✅ ${emojis.length} Emoji-Mappings migriert!`);
    } catch (error) {
        console.error('❌ Fehler bei Emoji-Migration:', error);
    }
}

async function runMigration() {
    console.log('🚀 Starte Daten-Migration...\n');
    
    await migrateResults();
    await migrateEmojis();
    
    console.log('\n✨ Migration abgeschlossen!');
    process.exit(0);
}

// Führe Migration aus
runMigration();
```

---

## 🖥️ Schritt 6: Hauptserver (Dashboard)

### Erstelle neuen `server.js`:

```javascript
// === HAUPTSERVER - SCHULOLYMPIADE DASHBOARD (Port 3000) ===
const express = require('express');
const { pool, testConnection } = require('./db');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

const app = express();
const PORT = process.env.MAIN_PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.static('public'));

// === IP LOGGING (bleibt auf JSON) ===
app.use((req, res, next) => {
    const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress || 'unknown';
    const now = new Date().toISOString();
    const logLine = `[${now}] ${ip} - ${req.method} ${req.originalUrl}\n`;
    
    const logPath = path.join(__dirname, 'data', 'api-logs.txt');
    fs.appendFile(logPath, logLine, err => {
        if (err) console.error('Log-Fehler:', err);
    });
    
    next();
});

// === API ENDPOINTS ===

// Statistiken
app.get('/api/stats', async (req, res) => {
    try {
        const [teams] = await pool.execute('SELECT COUNT(DISTINCT team) as count FROM results');
        const [disciplines] = await pool.execute('SELECT COUNT(DISTINCT disziplin) as count FROM results');
        const [events] = await pool.execute('SELECT COUNT(*) as count FROM results');
        
        res.json({
            totalParticipants: teams[0].count,
            totalDisciplines: disciplines[0].count,
            totalEvents: events[0].count,
            lastUpdate: new Date().toLocaleString('de-DE')
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Rangliste
app.get('/api/leaderboard', async (req, res) => {
    try {
        const [rows] = await pool.execute(`
            SELECT 
                team as name,
                COUNT(*) as events,
                SUM(punkte) as totalPoints,
                AVG(platz) as avgPlace
            FROM results
            GROUP BY team
            ORDER BY totalPoints DESC
            LIMIT 50
        `);
        
        const leaderboard = rows.map((row, index) => ({
            ...row,
            rank: index + 1,
            totalPoints: parseInt(row.totalPoints),
            avgPlace: parseFloat(row.avgPlace).toFixed(1)
        }));
        
        res.json(leaderboard);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Aktuelle Ergebnisse
app.get('/api/recent', async (req, res) => {
    try {
        const [rows] = await pool.execute(`
            SELECT 
                team,
                disziplin as discipline,
                punkte as points,
                platz as place,
                TIME_FORMAT(uhr, '%H:%i') as time
            FROM results
            ORDER BY created_at DESC, uhr DESC
            LIMIT 10
        `);
        
        res.json(rows);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Disziplinen
app.get('/api/disciplines', async (req, res) => {
    try {
        const [rows] = await pool.execute(`
            SELECT * FROM discipline_stats
        `);
        
        res.json(rows);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Server starten
app.listen(PORT, '0.0.0.0', async () => {
    console.log(`🚀 Hauptserver läuft auf http://localhost:${PORT}`);
    
    const connected = await testConnection();
    if (!connected) {
        console.error('⚠️ Keine Datenbankverbindung!');
    }
});
```

---

## ✏️ Schritt 7: Daten-Editor Server

### Erstelle `edit-server.js`:

```javascript
// === DATEN-EDITOR SERVER (Port 3003) ===
const express = require('express');
const crypto = require('crypto');
const { pool } = require('./db');
require('dotenv').config();

const app = express();
const PORT = process.env.EDIT_PORT || 3003;

// Token-Speicher
const validTokens = new Set();

// Middleware
app.use(express.json());
app.use(express.static(__dirname + '/edit-dashboard'));

// Hash für Passwort
const ADMIN_PASS_HASH = crypto.createHash('sha256')
    .update(process.env.ADMIN_PASS)
    .digest('hex');

// === AUTH ENDPOINTS ===
app.post('/api/login', async (req, res) => {
    const { username, password } = req.body;
    const hash = crypto.createHash('sha256').update(password).digest('hex');
    
    if (username === process.env.ADMIN_USER && hash === ADMIN_PASS_HASH) {
        const token = crypto.randomBytes(32).toString('hex');
        validTokens.add(token);
        
        // Token in DB speichern
        await pool.execute(
            'INSERT INTO auth_tokens (token) VALUES (?)',
            [token]
        );
        
        res.json({ success: true, token });
    } else {
        res.status(401).json({ success: false });
    }
});

// Auth Middleware
async function checkAuth(req, res, next) {
    const token = req.headers.authorization;
    
    if (!token) {
        return res.status(401).json({ error: 'Nicht autorisiert' });
    }
    
    // Prüfe Token in DB
    const [rows] = await pool.execute(
        'SELECT * FROM auth_tokens WHERE token = ? AND expires_at > NOW()',
        [token]
    );
    
    if (rows.length > 0) {
        next();
    } else {
        res.status(401).json({ error: 'Token ungültig' });
    }
}

// === DATA ENDPOINTS ===

// Alle Ergebnisse laden
app.get('/data/results.json', async (req, res) => {
    try {
        const [rows] = await pool.execute(`
            SELECT 
                team as Team,
                disziplin as Disziplin,
                punkte as Punkte,
                platz as Platz,
                TIME_FORMAT(uhr, '%H:%i:%s') as Uhr
            FROM results
            ORDER BY created_at DESC
        `);
        
        res.json(rows);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Daten speichern (komplett ersetzen)
app.post('/api/save', checkAuth, async (req, res) => {
    const connection = await pool.getConnection();
    
    try {
        await connection.beginTransaction();
        
        // Lösche alle alten Einträge
        await connection.execute('DELETE FROM results');
        
        // Füge neue Einträge ein
        for (const item of req.body) {
            await connection.execute(
                'INSERT INTO results (team, disziplin, punkte, platz, uhr) VALUES (?, ?, ?, ?, ?)',
                [item.Team, item.Disziplin, item.Punkte, item.Platz, item.Uhr]
            );
        }
        
        await connection.commit();
        res.json({ success: true });
        
    } catch (error) {
        await connection.rollback();
        res.status(500).json({ error: error.message });
    } finally {
        connection.release();
    }
});

// Server starten
app.listen(PORT, () => {
    console.log(`✏️ Daten-Editor läuft auf http://localhost:${PORT}`);
});
```

---

## 🎨 Schritt 8: Emoji-Editor Server

### Erstelle `emoji-server.js`:

```javascript
// === EMOJI-EDITOR SERVER (Port 3004) ===
const express = require('express');
const crypto = require('crypto');
const { pool } = require('./db');
require('dotenv').config();

const app = express();
const PORT = process.env.EMOJI_PORT || 3004;

// Token-Speicher
const validTokens = new Set();

// Middleware
app.use(express.json());
app.use(express.static(__dirname + '/emoji-dashboard'));

// Hash für Passwort
const ADMIN_PASS_HASH = crypto.createHash('sha256')
    .update(process.env.ADMIN_PASS)
    .digest('hex');

// === AUTH ENDPOINTS ===
app.post('/api/login', async (req, res) => {
    const { username, password } = req.body;
    const hash = crypto.createHash('sha256').update(password).digest('hex');
    
    if (username === process.env.ADMIN_USER && hash === ADMIN_PASS_HASH) {
        const token = crypto.randomBytes(32).toString('hex');
        validTokens.add(token);
        
        await pool.execute(
            'INSERT INTO auth_tokens (token) VALUES (?)',
            [token]
        );
        
        res.json({ success: true, token });
    } else {
        res.status(401).json({ success: false });
    }
});

// Auth Middleware
async function checkAuth(req, res, next) {
    const token = req.headers.authorization;
    
    if (!token) {
        return res.status(401).json({ error: 'Nicht autorisiert' });
    }
    
    const [rows] = await pool.execute(
        'SELECT * FROM auth_tokens WHERE token = ? AND expires_at > NOW()',
        [token]
    );
    
    if (rows.length > 0) {
        next();
    } else {
        res.status(401).json({ error: 'Token ungültig' });
    }
}

// === DATA ENDPOINTS ===

// Emoji-Mappings laden
app.get('/data/emojiMap.json', async (req, res) => {
    try {
        const [rows] = await pool.execute(`
            SELECT 
                emoji as Emoji,
                trigger_text as Trigger
            FROM emoji_mappings
            ORDER BY trigger_text
        `);
        
        res.json(rows);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Emoji-Mappings speichern
app.post('/api/save', checkAuth, async (req, res) => {
    const connection = await pool.getConnection();
    
    try {
        await connection.beginTransaction();
        
        // Lösche alle alten Mappings
        await connection.execute('DELETE FROM emoji_mappings');
        
        // Füge neue Mappings ein
        for (const item of req.body) {
            await connection.execute(
                'INSERT INTO emoji_mappings (emoji, trigger_text) VALUES (?, ?)',
                [item.Emoji, item.Trigger]
            );
        }
        
        await connection.commit();
        res.json({ success: true });
        
    } catch (error) {
        await connection.rollback();
        res.status(500).json({ error: error.message });
    } finally {
        connection.release();
    }
});

// Server starten
app.listen(PORT, () => {
    console.log(`😊 Emoji-Editor läuft auf http://localhost:${PORT}`);
});
```

---

## 🚀 Schritt 9: Start-Script

### Erstelle `start-all.js`:

```javascript
// === ALLE SERVER STARTEN ===
const { spawn } = require('child_process');
const { testConnection } = require('./db');

async function startServers() {
    console.log('🔍 Prüfe Datenbankverbindung...');
    
    const connected = await testConnection();
    if (!connected) {
        console.error('❌ Keine Datenbankverbindung! Beende...');
        process.exit(1);
    }
    
    console.log('🚀 Starte alle Server...\n');
    
    // Starte Hauptserver
    const mainServer = spawn('node', ['server.js'], {
        stdio: 'inherit'
    });
    
    // Starte Edit-Server
    const editServer = spawn('node', ['edit-server.js'], {
        stdio: 'inherit'
    });
    
    // Starte Emoji-Server
    const emojiServer = spawn('node', ['emoji-server.js'], {
        stdio: 'inherit'
    });
    
    // Handle Exit
    process.on('SIGINT', () => {
        console.log('\n🛑 Beende alle Server...');
        mainServer.kill();
        editServer.kill();
        emojiServer.kill();
        process.exit(0);
    });
}

startServers();
```

---

## 📂 Schritt 10: Verzeichnisstruktur

```
schulolympiade/
├── docker-compose.yml
├── init.sql
├── .env
├── package.json
├── db.js
├── migrate.js
├── server.js
├── edit-server.js
├── emoji-server.js
├── start-all.js
├── data/
│   ├── results.json (für Migration)
│   ├── emojiMap.json (für Migration)
│   └── api-logs.txt (bleibt JSON)
├── public/
│   ├── index.html
│   ├── script.js
│   └── style.css
├── edit-dashboard/
│   ├── index.html
│   ├── script.js
│   └── style.css
└── emoji-dashboard/
    ├── index.html
    ├── script.js
    └── style.css
```

---

## 🎯 Schritt 11: Installations-Anleitung

### 11.1 Vorbereitung:
```bash
# 1. Projekt-Verzeichnis erstellen
mkdir schulolympiade-mysql
cd schulolympiade-mysql

# 2. Alle Dateien kopieren (siehe Struktur oben)

# 3. NPM Pakete installieren
npm install
```

### 11.2 Datenbank starten:
```bash
# MySQL in Docker starten
docker-compose up -d

# Warte 30 Sekunden bis MySQL bereit ist
sleep 30

# Logs prüfen
docker-compose logs mysql
```

### 11.3 Daten migrieren:
```bash
# JSON-Daten in MySQL importieren
npm run migrate
```

### 11.4 Server starten:
```bash
# Alle Server gleichzeitig starten
node start-all.js

# ODER einzeln starten:
node server.js        # Dashboard (Port 3000)
node edit-server.js   # Daten-Editor (Port 3003)
node emoji-server.js  # Emoji-Editor (Port 3004)
```

---

## 🔐 Schritt 12: Sicherheits-Features

1. **Passwörter**: Alle in `.env` gespeichert
2. **Token**: Ablauf nach 24 Stunden
3. **SQL Injection**: Prepared Statements verwendet
4. **Connection Pool**: Verhindert Überlastung

---

## 🛠️ Schritt 13: Wartung & Backup

### Datenbank-Backup erstellen:
```bash
# Backup erstellen
docker exec schulolympiade_mysql mysqldump -u root -p'olympiade2025!' schulolympiade > backup_$(date +%Y%m%d).sql

# Backup wiederherstellen
docker exec -i schulolympiade_mysql mysql -u root -p'olympiade2025!' schulolympiade < backup_20240625.sql
```

### Logs ansehen:
```bash
# MySQL Logs
docker-compose logs -f mysql

# API Logs (bleibt in JSON)
tail -f data/api-logs.txt
```

---

## ✅ Schritt 14: Test-Checkliste

- [ ] Docker Container läuft (`docker ps`)
- [ ] MySQL erreichbar auf Port 3308
- [ ] Migration erfolgreich (`npm run migrate`)
- [ ] Dashboard erreichbar auf http://192.168.100.73:3000
- [ ] Login funktioniert mit DauView25 / ongOlympiade#2025
- [ ] Daten werden korrekt angezeigt
- [ ] Bearbeitung funktioniert
- [ ] Emoji-Mappings funktionieren

---

## 🆘 Fehlerbehebung

### MySQL Verbindungsfehler:
```bash
# Prüfe Container Status
docker-compose ps

# Prüfe MySQL Logs
docker-compose logs mysql

# Teste Verbindung manuell
docker exec -it schulolympiade_mysql mysql -u olympiade_user -p
```

### Port bereits belegt:
```bash
# Finde Prozess auf Port
lsof -i :3308

# Ändere Port in docker-compose.yml
ports:
  - "3309:3306"  # Neuer Port
```

### Migration schlägt fehl:
```bash
# Prüfe JSON-Dateien
cat data/results.json | jq .
cat data/emojiMap.json | jq .

# Führe Migration mit Debug aus
DEBUG=* node migrate.js
```

---

## 📝 Zusammenfassung

Diese Migration bietet:
- ✅ **Zentrale MySQL Datenbank** statt verteilter JSON-Dateien
- ✅ **Bessere Performance** durch Indizes und Views
- ✅ **Transaktionssicherheit** bei Updates
- ✅ **Einfaches Backup** der gesamten Datenbank
- ✅ **IP-Logging bleibt in JSON** wie gewünscht
- ✅ **Alle Funktionen** bleiben erhalten

Die Frontend-Codes müssen NICHT geändert werden, da die API-Endpoints gleich bleiben!